**霍夫变换是一种在图像中寻找直线、圆形以及其他简单形状的方法**。霍夫变换采用类似于投票的方式来获取当前图像内的形状集合，该变换由Paul Hough（霍夫）于1962年首次提出。最初的霍夫变换只能用于检测直线，经过发展后，霍夫变换不仅能够识别直线，还能识别其他简单的图形结构，常见的有圆、椭圆等。

霍夫直线变换用来在图像内寻找直线，霍夫圆变换用来在图像内寻找圆。在OpenCV中，前者可以用函数cv2.HoughLines()和函数cv2.HoughLinesP()实现，后者可以用函数cv2.HoughCircles()实现。

## 霍夫直线变换

### 霍夫变换原理

与笛卡儿坐标系对应，我们构造一个霍夫坐标系（对应于霍夫空间）。在霍夫坐标系中，横坐标采用笛卡儿坐标系中直线的斜率k，纵坐标使用笛卡儿坐标系中直线的截距b。

● 笛卡儿空间内的一条直线确定了霍夫空间内的一个点。

● 霍夫空间内的一个点确定了笛卡儿空间内的一条直线。

● 笛卡儿空间内的点（x0, y0）映射到霍夫空间，就是直线b=-x0k+y0。

● 霍夫空间内的直线b=-x0k+y0映射到笛卡儿空间，就是点（x0, y0）。

● 笛卡儿空间内的两个点会映射为霍夫空间内两条相交于(k1,b1)的直线。

● 这两个点对应的直线会映射为霍夫空间内的点(k1,b1)。

![](https://s2.loli.net/2022/12/15/HDU5z1gYF68KeGc.png)

如果在笛卡儿空间内，有N个点能够连成一条直线y=k1x+b1，那么在霍夫空间内就会有N条直线穿过对应的点(k1, b1)。或者反过来说，如果在霍夫空间中，有越多的直线穿过点(k1, b1)，就说明在笛卡儿空间内有越多的点位于斜率为k1，截距为b1的直线y=k1x+b1上。

在霍夫空间内，经过一个点的直线越多，说明其在笛卡儿空间内映射的直线，是由越多的点所构成（穿过）的。我们知道，两个点就能构成一条直线。但是，如果有一个点是因为计算错误而产生的，那么它和另外一个点，也会构成一条直线，此时就会凭空构造出一条实际上并不存在的直线。这种情况是要极力避免的。因此，在计算中，我们希望用更多的点构造一条直线，以提高直线的可靠性。也就是说，如果一条直线是由越多点所构成的，那么它实际存在的可能性就越大，它的可靠性也就越高。因此，**霍夫变换选择直线的基本思路是：选择有尽可能多直线交汇的点**。

![](https://s2.loli.net/2022/12/15/Nfr4AhTMWlBqd98.png)

斜率k为无穷大，截距b无法取值。垂线无法映射到霍夫空间内。为了解决上述问题，可以考虑将笛卡儿坐标系映射到极坐标系上，在笛卡儿坐标系内使用的是斜率k和截距b，即用(k, b)表示一条直线。在极坐标系内，采用极径r（有时也用ρ表示）和极角θ来表示，即(r, θ)来表示。极坐标系中的直线可以表示为：

r=xcosθ+ysinθ

+ 极坐标系内的一个点映射为霍夫坐标系（霍夫空间）内的一条线（曲线）。
+ 极坐标系内的一条线映射为霍夫坐标系内的一个点。

直线LineA，可以使用极坐标的极径r和极角θ来表示。其中，r是直线LineA与图像原点O之间的距离，参数θ是直线LineA的垂线LineB与x轴的角度。在这种表示方法中，图像中的直线有一个（0~π）的角θ，而r的最大值是图像对角线的长度。

在极坐标系内的一条直线能够通过在霍夫坐标系内相交于一点的线的数量来评估。在霍夫坐标系内，经过一个点的线越多，说明其映射在极坐标系内的直线，是由越多的点所构成（穿过）的。因此，霍夫变换选择直线的基本思路是：**选择由尽可能多条线汇成的点**。

### HoughLines函数
OpenCV提供了函数cv2.HoughLines()用来实现霍夫直线变换，该函数要求所操作的源图像是一个**二值图像**，所以在进行霍夫变换之前要先将源图像进行二值化，或者进行Canny边缘检测。

```python
lines=cv2.HoughLines(image, rho, theta, threshold)
```


+ image是输入图像，即源图像，必须是8位的单通道二值图像。如果是其他类型的图像，在进行霍夫变换之前，需要将其修改为指定格式。
+ rho为以像素为单位的距离r的精度。一般情况下，使用的精度是1。
+ theta为角度θ的精度。一般情况下，使用的精度是π/180，表示要搜索所有可能的角度。
+ threshold是阈值。该值越小，判定出的直线就越多。通过上一节的分析可知，识别直线时，要判定有多少个点位于该直线上。在判定直线是否存在时，对直线所穿过的点的数量进行评估，如果直线所穿过的点的数量小于阈值，则认为这些点恰好（偶然）在算法上构成直线，但是在源图像中该直线并不存在；如果大于阈值，则认为直线存在。所以，如果阈值较小，就会得到较多的直线；阈值较大，就会得到较少的直线。
+ 返回值lines中的每个元素都是一对浮点数，表示检测到的直线的参数，即(r,θ)，是numpy.ndarray类型。

### HoughLinesP函数
概率霍夫变换对基本霍夫变换算法进行了一些修正，是霍夫变换算法的优化。它没有考虑所有的点。相反，它只需要一个足以进行线检测的随机点子集即可。

## 霍夫圆环变换
霍夫变换除了用来检测直线外，也能用来检测其他几何对象。实际上，只要是能够用一个参数方程表示的对象，都适合用霍夫变换来检测。

用霍夫圆变换来检测图像中的圆，与使用霍夫直线变换检测直线的原理类似。在霍夫圆变换中，需要考虑圆半径和圆心（x坐标、y坐标）共3个参数。在OpenCV中，采用的策略是两轮筛选。第1轮筛选找出可能存在圆的位置（圆心）；第2轮再根据第1轮的结果筛选出半径大小。与用来决定是否接受直线的两个参数“接受直线的最小长度（minLineLength）”和“接受直线时允许的最大像素点间距（MaxLineGap）”类似，霍夫圆变换也有几个用于决定是否接受圆的参数：圆心间的最小距离、圆的最小半径、圆的最大半径。

```python
circles=cv2.HoughCircles(image,method,dp,minDist,param1,param2,minRadius,maxRadius)
```

+ image：输入图像，即源图像，类型为8位的单通道灰度图像。
+ method：检测方法。截止到OpenCV 4.0.0-pre版本，HOUGH_GRADIENT是唯一可用的参数值。该参数代表的是霍夫圆检测中两轮检测所使用的方法。
+ dp：累计器分辨率，它是一个分割比率，用来指定图像分辨率与圆心累加器分辨率的比例。例如，如果dp=1，则输入图像和累加器具有相同的分辨率。
+ minDist：圆心间的最小间距。该值被作为阈值使用，如果存在圆心间距离小于该值的多个圆，则仅有一个会被检测出来。因此，如果该值太小，则会有多个临近的圆被检测出来；如果该值太大，则可能会在检测时漏掉一些圆。
+ param1：该参数是缺省的，在缺省时默认值为100。它对应的是Canny边缘检测器的高阈值（低阈值是高阈值的二分之一）。
+ param2：圆心位置必须收到的投票数。只有在第1轮筛选过程中，投票数超过该值的圆，才有资格进入第2轮的筛选。因此，该值越大，检测到的圆越少；该值越小，检测到的圆越多。这个参数是缺省的，在缺省时具有默认值100。
+ minRadius：圆半径的最小值，小于该值的圆不会被检测出来。该参数是缺省的，在缺省时具有默认值0，此时该参数不起作用。
+ maxRadius：圆半径的最大值，大于该值的圆不会被检测出来。该参数是缺省的，在缺省时具有默认值0，此时该参数不起作用。
+ circles：返回值，由圆心坐标和半径构成的numpy.ndarray。

在调用函数cv2.HoughLinesCircles()之前，要对源图像进行平滑操作，以减少图像中的噪声，避免发生误判。

> 使用HoughLinesCircles函数对一幅图像进行霍夫圆变换，并观察检测效果。

```python
import cv2
import numpy as np
import matplotlib.pyplot as plt
img = cv2.imread('chess.jpg',0)
imgo=cv2.imread('chess.jpg', -1)
o=cv2.cvtColor(imgo, cv2.COLOR_BGR2RGB)
oshow=o.copy()
img = cv2.medianBlur(img,5)
circles = cv2.HoughCircles(img, cv2.HOUGH_GRADIENT,1,300,
                           param1=50, param2=30, minRadius=100, maxRadius=200)
circles = np.uint16(np.around(circles))
for i in circles[0, :]:
    cv2.circle(o, (i[0], i[1]), i[2], (255,0,0),12)
    cv2.circle(o, (i[0], i[1]),2, (255,0,0),12)
 plt.subplot(121)
 plt.imshow(oshow)
 plt.axis('off')
 plt.subplot(122)
 plt.imshow(o)
 plt.axis('off')
```

在检测中，可能需要不断调整参数才能得到最优结果。