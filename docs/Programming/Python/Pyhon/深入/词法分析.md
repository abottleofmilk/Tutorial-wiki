# 词法分析
## 标注
```
name      ::=  lc_letter (lc_letter | "_")*
lc_letter ::=  "a"..."z"
```
第一行表示 name 是 lc_letter 之后跟零个或多个 lc_letter 和下划线。而 lc_letter 则是任意单个 'a' 至 'z' 字符。(实际上在本文档中始终采用此规则来定义词法和语法规则的名称。)

每条规则的开头是一个名称 (即该规则所定义的名称) 加上 ::=。 竖线 (|) 被用来分隔可选项，它是此标注中绑定程度最低的操作符。 星号 (*) 表示前一项的零次或多次重复，类似地，加号 (+) 表示一次或多次重复，而由方括号括起的内容 ([ ]) 表示出现零次或一次 (或者说，这部分内容是可选的)。 * 和 + 操作符的绑定是最紧密的，圆括号用于分组。 字符串字面值包含在引号内。 空格的作用仅限于分隔形符。 每条规则通常为一行，有许多个可选项的规则可能会以竖线为界分为多行。

在词法定义中 (如上述示例)，还额外使用了两个约定: 由三个点号分隔的两个字符字面值表示在指定 (闭) 区间范围内的任意单个 ASCII 字符。由尖括号 (<...>) 括起来的内容是对于所定义符号的非正式描述；即可以在必要时用来说明 ‘控制字符’ 的意图。

虽然所用的标注方式几乎相同，但是词法定义和句法定义是存在很大区别的: 词法定义作用于输入源中单独的字符，而句法定义则作用于由词法分析所生成的形符流。在下一章节 (“词法分析”) 中使用的 BNF 全部都是词法定义；在之后的章节中使用的则是句法定义。
## 行结构

## 其他形符

## 关键字
```
False      await      else       import     pass
None       break      except     in         raise
True       class      finally    is         return
and        continue   for        lambda     try
as         def        from       nonlocal   while
assert     del        global     not        with
async      elif       if         or         yield
```
### 软关键字

某些标识符仅在特定上下文中被保留。 它们被称为 软关键字。 match, case 和 _ 等标识符在模式匹配语句相关的上下文中具有相当于关键字的语义，但这种区分是在解析器层级完成，而不是在形符化的时候。作为软关键字，它们能够与模式匹配一起使用，同时仍然保持与使用 match, case 和 _ 作为标识符名称的现有代码的兼容性。

## 字面值
