# Python文件操作
## 文件介绍
 每个运行在计算机上的程序，都有一个“当前工作目录”（或 cwd）。所有没有从根文件夹开始的文件名或路径，都假定在当前工作目录下。
+ 绝对路径：总是从根文件夹开始，Window 系统中以盘符（C：、D：）作为根文件夹，而 OS X 或者 Linux 系统中以 / 作为根文件夹。
+ 相对路径：指的是文件相对于当前工作目录所在的位置。

在 Windows 上，路径书写使用反斜杠 "\\" 作为文件夹之间的分隔符。但在 OS X 和 Linux 上，使用正斜杠 "/" 作为它们的路径分隔符。如果想要程序运行在所有操作系统上，在编写 Python 脚本时，就必须处理这两种情况。任何一门编程语言中，文件的输入输出、数据库的连接断开等，都是很常见的资源管理操作。但资源都是有限的，在写程序时，必须保证这些资源在使用过后得到释放，不然就容易造成资源泄露，轻者使得系统处理缓慢，严重时会使系统崩溃。

## 基本使用
> 打开
```python
open()
```
> 关闭
```python
close()
```
> 读写
```python
read() #读一个文件
readline() #读单行
readlines() #读多行 返回是一个字符串列表，其中每个元素为文件中的一行内容。
write() #写文件
writelines() #写入多行 字符串序列
```
## 核心概念
### 文件指针
```python
 tell() #读取指针位置
 seek() #将文件指针移动至指定位置
```
file.seek(offset[, whence])
其中，各个参数的含义如下：

+ file：表示文件对象；  
+ whence：作为可选参数，用于指定文件指针要放置的位置，该参数的参数值有 3 个选择：0 代表文件头（默认值）、1 代表当前位置、2 代表文件尾。
+ offset：表示相对于 whence 位置文件指针的偏移量，正数表示向后偏移，负数表示向前偏移。例如，当whence == 0 &&offset == 3（即 seek(3,0) ），表示文件指针移动至距离文件开头处 3 个字符的位置；当whence == 1 &&offset == 5（即 seek(5,1) ），表示文件指针向后移动，移动至距离当前位置 5 个字符处。
  

当 offset 值非 0 时，Python 要求文件必须要以二进制格式打开，否则会抛出 io.UnsupportedOperation 错误。
### flush&close
在写入文件完成后，一定要调用 close() 函数将打开的文件关闭，否则写入的内容不会保存到文件中,因为，当我们在写入文件内容时，操作系统不会立刻把数据写入磁盘，而是先缓存起来，只有调用 close() 函数时，操作系统才会保证把没有写入的数据全部写入磁盘文件中。如果向文件写入数据后，不想马上关闭文件，也可以调用文件对象提供的 flush() 函数，它可以实现将缓冲区的数据写入文件中。

### 上下文管理器
简单的理解，同时包含 `__enter__`() 和 `__exit__`() 方法的对象就是上下文管理器。也就是说，上下文管理器必须实现如下两个方法：
 当 with as 操作上下文管理器时，就会在执行语句体之前，先执行上下文管理器的`__enter__`() 方法，然后再执行语句体，最后执行`__exit__`() 方法。

 构建上下文管理器，常见的有 2 种方式：基于**类实现**和基于**生成器**实现。
+ `__enter__`(self)：进入上下文管理器自动调用的方法，该方法会在 with as 代码块执行之前执行。如果 with 语句有 as子句，那么该方法的返回值会被赋值给 as 子句后的变量；该方法可以返回多个值，因此在 as 子句后面也可以指定多个变量（多个变量必须由“()”括起来组成元组）。
+ `__exit__`（self, exc_type, exc_value, exc_traceback）：退出上下文管理器自动调用的方法。该方法会在 with as 代码块执行之后执行。如果 with as 代码块成功执行结束，程序自动调用该方法，调用该方法的三个参数都为 None：如果 with as 代码块因为异常而中止，程序也自动调用该方法，使用 sys.exc_info 得到的异常信息将作为调用该方法的参数。

```Python
from contextlib import contextmanager

@contextmanager
def file_manager(name, mode):
    try:
        f = open(name, mode)
        yield f
    finally:
        f.close()
       
with file_manager('a.txt', 'w') as f:
    f.write()
```
基于类的上下文管理器和基于生成器的上下文管理器，这两者在功能上是一致的。只不过，基于类的上下文管理器更加灵活，适用于大型的系统开发，而基于生成器的上下文管理器更加方便、简洁，适用于中小型程序。但是，无论使用哪一种，不用忘记在方法“`__exit__`()”或者是 finally 块中释放资源，这一点尤其重要。

### 常用函数

```python
 fileinput.input（files="filename1, filename2, ...", inplace=False, backup='', bufsize=0, mode='r', openhook=None）
```

+ fileinput模块：逐行读取多个文件。 此函数会返回一个 FileInput 对象，它可以理解为是将多个指定文件合并之后的文件对象。

+ linecache 模块。和前者不同，linecache 模块擅长读取指定文件中的指定行。换句话说，如果我们想读取某个文件中指定行包含的数据，就可以使用 linecache 模块。使用该模块读取的文件，其编码格式也必须为 UTF-8，否则要么读取出来的数据是乱码，要么直接读取失败（Python 解释器会报 SyntaxError 异常）。

+ fnmatch 模块主要用于文件名称的匹配，其能力比简单的字符串匹配更强大，但比使用正则表达式相比稍弱。。如果在数据处理操作中，只需要使用简单的通配符就能完成文件名的匹配，则使用 fnmatch 模块是不错的选择。
+ tempfile模块：生成临时文件和临时目录
+ pathlib 模块的操作对象是各种操作系统中使用的路径（例如指定文件位置的路径，包括绝对路径和相对路径）

## 序列化

[Python](http://c.biancheng.net/python/) 中有个序列化过程叫作 pickle，它能够实现任意对象与文本之间的相互转化，也可以实现任意对象与二进制之间的相互转化。也就是说，pickle 可以实现 Python 对象的存储及恢复。

pickle 模块提供了以下 4 个函数供我们使用：

1. dumps()：将 Python 中的对象序列化成二进制对象，并返回；
2. loads()：读取给定的二进制对象数据，并将其转换为 Python 对象；
3. dump()：将 Python 中的对象序列化成二进制对象，并写入文件；
4. load()：读取指定的序列化数据文件，并返回对象。

看似强大的 pickle 模块，其实也有它的短板，即 pickle 不支持并发地访问持久性对象，在复杂的系统环境下，尤其是读取海量数据时，使用 pickle 会使整个系统的`I/O`读取性能成为瓶颈。这种情况下，可以使用 ZODB。 ZODB 是一个健壮的、多用户的和面向对象的数据库系统，专门用于存储 Python 语言中的对象数据，它能够存储和管理任意复杂的 Python  对象，并支持事务操作和并发控制。并且，ZODB 也是在 Python 的序列化操作基础之上实现的，因此要想有效地使用 ZODB，必须先学好  pickle。
