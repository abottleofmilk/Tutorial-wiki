结构是程序员定义的数据类型，与类非常类似。它们有数据成员和函数成员。虽然与类相似，但是结构有许多重要的区别。最重要的区别是:

+ 类是引用类型，而结构是值类型;
+ 结构是隐式密封的,这意味着不能从它们派生其他结构。



![image-20221206143438963](https://s2.loli.net/2022/12/06/NfdeVobt6HrRJYg.png)



![image-20221206143503099](https://s2.loli.net/2022/12/06/xuvMflGkN6KtroZ.png)

### 结构是值类型

和所有值类型—样,结构类型变量含有自己的数据。因此:

+ 结构类型的变量不能为null;
+ 两个结构变量不能引用同一对象。

![image-20221206143802074](https://s2.loli.net/2022/12/06/sjuwWLytiAmYR2c.png)

### 对结构赋值

把一个结构赋值给另一个结构，就是将一个结构的值复制给另---个结构。这和复制类变量不同，复制类变量时只复制引用。



![image-20221206144117373](https://s2.loli.net/2022/12/06/VMO1uIBlKGX4zJF.png)



![image-20221206144058259](https://s2.loli.net/2022/12/06/n8jE97D4Pa3fRHV.png)

### 构造函数和析构函数

结构可以有实例构造函数和静态构造函数，但不允许有析构函数。

### 实例构造函数



### 属性和字段初始化语句

在声明结构体时，不允许使用实例属性和字段初始化语句，如下所示。

![image-20221206145120038](https://s2.loli.net/2022/12/06/3bYV9hAoSDcxrC2.png)

但是，结构体的静态属性和静态字段都可以在声明结构体时进行初始化，**即使结构体本身不是静态的**。

### 结构是密封的

结构总是隐式密封的，因此，不能从它们派生其他结构。

由于结构不支持继承，个别类成员修饰符用在结构成员上将没有意义，因此不能在结构成员声明中使用。不能用于结构的修饰符如下:

+ protected
+ protected internal
+ abstract
+ sealed
+ virtual

结构本身派生自System.ValueType，而System.ValueType派生自object。两个可以用于结构成员并与继承相关的关键字是new和 override 修饰符，当创建一个和基类System.valueType的成员同名的成员时可使用它们。所有结构都派生自System.ValueType。

### 装箱和拆箱

如同其他值类型数据，如果想将一个结构实例作为引用类型对象，必须创建装箱（ boxing)的副本。装箱的过程就是制作值类型变量的引用类型副本。

### 结构作为返回值和参数

结构可以用作返回值和参数。

+ 返回值当结构作为返回值时，将创建它的副本并从函数成员返回。
+ 值参数当结构被用作值参数时，将创建实参结构的副本。该副本用于方法的执行中。
+ ref和out参数如果把一个结构用作ref或out参数，传入方法的是该结构的一个引用，这样就可以修改其数据成员。

### 关于结构的更多内容

对结构进行分配的开销比创建类实例小,所以使用结构代替类有时可以提高性能，但要注意装箱和拆箱的高昂代价。

关于结构,需要知道的最后一些事情如下。预定义简单类型( int、short、long，等等)，尽管在.NET 和C#中被视为原始类型，但它们实际上在.NET中都实现为结构。可以使用与声明分部类相同的方法声明分部结构。结构和类一样，可以实现接口。